#include "StreetsDatabaseAPI.h"
#include "m1.h"
#include <vector>
#include <cmath>
#include <algorithm>
#include <structure.h>
#define PI 3.14159265358979323846264338327950288419716939937

//load the map
vector<unsigned>* intersections_segments;
dataStructureSingleton* dataStructureSingleton::dataStructure = NULL;

bool load_map(std::string map_name) {

    bool load_success = loadStreetsDatabaseBIN(map_name);

//    // create any data structures here to speed up your API functions
    unsigned number_of_intersections;
    number_of_intersections = getNumberOfIntersections();
   
    dataStructureSingleton::dataStructures(); // load data structure
    intersections_segments = new vector<unsigned> [number_of_intersections];
    for (unsigned i = 0; i < number_of_intersections; i++)
        intersections_segments[i] = dataStructureSingleton::dataStructures()->findIntersectionStreetSeg(i);
    return load_success;
}

//close the map

void close_map() {
    delete [] intersections_segments;
    intersections_segments=NULL;
    dataStructureSingleton::dataStructures()->deleteStruc();
    closeStreetDatabase();

    // destroy/clear any data structures you created in load_map
    // ...
}

//implement the rest of the functions provided in m1.h
// ...


//function to return street id(s) for a street name
//return a 0-length vector if no street with this name exists.

//using structure StNameToID_instance (Done)

std::vector<unsigned> find_street_ids_from_name(std::string street_name) {
    return dataStructureSingleton::dataStructures()->findStreetIDFromName(street_name);
}

std::vector<unsigned> find_intersection_street_segments(unsigned intersection_id) {
    //return dataStructureSingleton::dataStructures()->findIntersectionStreetSeg(intersection_id);
    return intersections_segments[intersection_id];
    }

std::vector<std::string> find_intersection_street_names(unsigned intersection_id) {
    std::vector<std::string> streetNamesVec;

    //use the previous function to find out all the intersected street IDs
    std::vector<unsigned> streetSegIDVec;
    streetSegIDVec = find_intersection_street_segments(intersection_id);

    //use a for loop with iterator to go through the streetSegIDVec and store
    //their names in a streetNamesVector
    for (std::vector<unsigned>::iterator strSegIDItr = streetSegIDVec.begin();
            strSegIDItr != streetSegIDVec.end();
            strSegIDItr++) {
        StreetSegmentInfo tempStreetSegInfo = getStreetSegmentInfo(*strSegIDItr);
        unsigned tempStreetID = tempStreetSegInfo.streetID;
        streetNamesVec.push_back(getStreetName(tempStreetID));
    }

    return streetNamesVec;
}

bool are_directly_connected(unsigned intersection_id1, unsigned intersection_id2) {
    if (intersection_id1 == intersection_id2)
        return true;

    std::vector<unsigned> streetSegIDVec1 = find_intersection_street_segments(intersection_id1);
    std::vector<unsigned> streetSegIDVec2 = find_intersection_street_segments(intersection_id2);

    //declare a vector of street segment IDs (to store common segments IDs) and 
    //its iterator
    std::vector<unsigned> commonStreetSegIDVec(10);
    std::vector<unsigned>::iterator commonStreetSegIt;
    commonStreetSegIt = std::set_intersection(streetSegIDVec1.begin(), streetSegIDVec1.end(),
            streetSegIDVec2.begin(), streetSegIDVec2.end(), commonStreetSegIDVec.begin());
    commonStreetSegIDVec.resize(commonStreetSegIt - commonStreetSegIDVec.begin());

    //the commonStreetSegIDVec is empty if those two intersection doesn't have any 
    //street segment in common
    if (commonStreetSegIDVec.size() == 0)
        return false;

    for (commonStreetSegIt = commonStreetSegIDVec.begin();
            commonStreetSegIt != commonStreetSegIDVec.end();
            commonStreetSegIt++) {
        StreetSegmentInfo tempStreetSegInfo = getStreetSegmentInfo(*commonStreetSegIt);
        //if the vector is not empty and the segment is not one way, those two
        //intersections are directly connected
        if (!tempStreetSegInfo.oneWay)
            return true;
        //else check if it is the right way
        if (tempStreetSegInfo.from == intersection_id1
                && tempStreetSegInfo.to == intersection_id2)
            return true;
    }
    return false;
}




//Using structure Intersection_HashTable

std::vector<unsigned> find_adjacent_intersections(unsigned intersection_id) {
    return dataStructureSingleton::dataStructures()->getAllAdjacentIntersections(intersection_id);
}


//Using structure StreetIDStruct_HashTable 

std::vector<unsigned> find_street_street_segments(unsigned street_id) {
    return dataStructureSingleton::dataStructures()->getAllStreetSegForStreet(street_id);
}


//Using structure StreetIDStruct_HashTable

std::vector<unsigned> find_all_street_intersections(unsigned street_id) {
    return dataStructureSingleton::dataStructures()->getStreetIntersectionsVector(street_id);
}


//Doesn't use any structure

std::vector<unsigned> find_intersection_ids_from_street_names(std::string street_name1, std::string street_name2) {
    

    std::vector<unsigned> intersectionIDs1 = dataStructureSingleton::dataStructures() ->getStreetNameIntersectionsVector(street_name1);
    std::vector<unsigned> intersectionIDs2 = dataStructureSingleton::dataStructures() ->getStreetNameIntersectionsVector(street_name2);

    return find_same_intersections(intersectionIDs1, intersectionIDs2);

}





//get the longitude and latitude of two points
//transfer (lon, lat) into (x,y)
//d = R * sqrt((y2 - y1)^2 + (x2 - x1)^2)
//return the result
<<<<<<< .mine
//O(1))
double find_distance_between_two_points(LatLon point1, LatLon point2){
    
=======
//Doesn't use any structure

double find_distance_between_two_points(LatLon point1, LatLon point2) {
>>>>>>> .r49
    //initialize variables
    double distance = 0;
    double lon1, lat1, lon2, lat2, latavg, p1x, p1y, p2x, p2y;

    //convert the decimal degrees to radians
    lon1 = point1.lon / 180 * PI;
    lon2 = point2.lon / 180 * PI;
    lat1 = (point1.lat) / 180 * PI;
    lat2 = (point2.lat) / 180 * PI;
    latavg = (lat1 + lat2) / 2;

    //transfer the points from Lat Lon domain into X Y domain
    p1x = lon1 * cos(latavg);
    p1y = lat1;
    p2x = lon2 * cos(latavg);
    p2y = lat2;

    //use the equation to find out the distance between two points
    distance = EARTH_RADIUS_IN_METERS * sqrt(pow(p2y - p1y, 2) + pow(p2x - p1x, 2));
    return distance;
}

//check the number of curve points of input street segment
//if 1 => use find_distance_between_two_points directly
//else => figure out the distance between each connected curve points and add the distance up
<<<<<<< .mine
//
double find_street_segment_length(unsigned street_segment_id){
    //initilize the current street
    StreetSegmentInfo current_street = getStreetSegmentInfo( street_segment_id );
    
=======

double find_street_segment_length(unsigned street_segment_id) {
    //initialize the current street
    StreetSegmentInfo current_street = getStreetSegmentInfo(street_segment_id);

>>>>>>> .r49
    //initialize the starting point and ending point
    LatLon onset = getIntersectionPosition(current_street.from);
    LatLon offset = getIntersectionPosition(current_street.to);

    //initialize the length of current street segment
    double length = 0;

    //no curve point
    //just calculate the distance between starting point and ending point
    if (current_street.curvePointCount == 0) {

        length = find_distance_between_two_points(onset, offset);

    } else if (current_street.curvePointCount == 1) {

        LatLon current_curve_point = getStreetSegmentCurvePoint(street_segment_id, 0);
        length = find_distance_between_two_points(onset, current_curve_point) + find_distance_between_two_points(current_curve_point, offset);

    } else {//a loop to add up every parts length

        LatLon last_curve_point = getStreetSegmentCurvePoint(street_segment_id, current_street.curvePointCount - 1);
        LatLon current_curve_point = getStreetSegmentCurvePoint(street_segment_id, 0);
        length = find_distance_between_two_points(onset, current_curve_point) + find_distance_between_two_points(last_curve_point, offset);

        for (unsigned i = 0, j = 1; i < current_street.curvePointCount - 1; i++, j++) {
            length += find_distance_between_two_points(getStreetSegmentCurvePoint(street_segment_id, i), getStreetSegmentCurvePoint(street_segment_id, j));
        }

        //don't delete the following code
        
    }
    //jump out of loop && finish calculation
    return length;
}

//check the number of segment of the street
//figure out the distance between each street segments and add the distance up
<<<<<<< .mine
//Maybe this function could be faster
double find_street_length(unsigned street_id){
    
=======

double find_street_length(unsigned street_id) {

>>>>>>> .r49
    //find all intersection of this street
    std::vector<unsigned> street_segment_id = find_street_street_segments(street_id);

    //initialize the length of the street
    double length = 0;

    //a loop to calculate the length of the street
    for (std::vector<unsigned>::size_type idx = 0; idx < street_segment_id.size(); idx++) {
        length += find_street_segment_length(*(street_segment_id.begin() + idx));
    }

    return length;
}

// time = distance / speed

double find_street_segment_travel_time(unsigned street_segment_id) {

    //figure out the street segment info first
    StreetSegmentInfo current_street = getStreetSegmentInfo(street_segment_id);

    //find the street_segment_length first
    double length = find_street_segment_length(street_segment_id);

    //T = X / V
    double time = length / (double) current_street.speedLimit * 60 / 1000;

    return time;
}


//algorithm to get the closest point of interest with O(n)

unsigned find_closest_point_of_interest(LatLon my_position) {

    //initialize the beginning ID
    unsigned closestPointOfInterestID = 0;

    //set the initial value of closestDis to a arbitrary large number   
    double closestDis = 10000;

    //go through all the street IDs to find out the ones with smallest difference
    //in LatLon
    for (unsigned pointOfInterestID = 0; pointOfInterestID < getNumberOfPointsOfInterest(); pointOfInterestID++) {

        //create the tempo position as a potential position
        LatLon potential_position = getPointOfInterestPosition(pointOfInterestID);

        //store the distance between my position and the current point of interest
        double curDis = find_distance_between_two_points(my_position, potential_position);

        //if it is smaller than the closestDis so far, replace it
        //what the result that I am at a point of interest
        if (curDis < closestDis) {
            closestPointOfInterestID = pointOfInterestID;
            closestDis = curDis;
        }
    }
    return closestPointOfInterestID;
}

//algorithm to get the closest intersection with O(n)

unsigned find_closest_intersection(LatLon my_position) {

    //initialize the intersection id
    unsigned closest_intersection_id = 0;

    //initialize the distance with a large number
    double distance = 99999;

    //to get the number of intersection
    unsigned NumOfInt = getNumberOfIntersections();

    //the average latitude
    double convert_factor = PI / 180.0;

    //this is the average latitude of Toronto
    double LatAvg = 43.7 * convert_factor;

    //this one shorten the calculation
    double cosine_factor = cos(LatAvg);

    double my_x = my_position.lon * convert_factor * cosine_factor;
    double my_y = my_position.lat * convert_factor;

    //compare the distance between each other section and the target section
    for (unsigned intersection_id = 0; intersection_id < NumOfInt; intersection_id++) {

        //temporary position and distance
        LatLon potential_position = getIntersectionPosition(intersection_id);
        //double tempo_distance = find_distance_between_two_points(my_position, potential_position);

        double _x = potential_position.lon * convert_factor * cosine_factor;
        double _y = potential_position.lat * convert_factor;



        double current_distance = pow(_x - my_x, 2) + pow(_y - my_y, 2);
        //compare the distance
        //What is the result that I am in an intersection?
        if (current_distance < distance) {
            distance = current_distance;
            closest_intersection_id = intersection_id;
        }
    }

    //jump out of the loop && return the intersection id
    return closest_intersection_id;
}



//finds common values to two vectors 
//returns a vector containing all common valueshhhhhhh
//e.g. same intersections

std::vector<unsigned> find_same_intersections(std::vector<unsigned> & intersections1,
        std::vector<unsigned> & intersections2) {

    std::vector<unsigned> sameIntersections; // vector to store all intersections
    //sort vectors
    std::sort(intersections1.begin(), intersections1.end());
    std::sort(intersections2.begin(), intersections2.end());
    //gets common vales
    std::set_intersection(intersections1.begin(), intersections1.end(),
            intersections2.begin(), intersections2.end(),
            std::back_inserter(sameIntersections));
    return sameIntersections;
}

